Hauptkomponente für die GUI des Remote-Logger-Clients im ADITO4-Manager
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Panel des RemoteLogger-Clients im Manager
 *
 * @author W.Glanzer, 19.11.2015
 */
public class RemoteLoggerPanel extends AbstractDetailPanel
{
  private final RemoteLoggerTreeTable treeTable;
  private final RemoteLoggerDetailsPanel detailsPanel;
  private JToggleButton connectionButton;

  public RemoteLoggerPanel(RemoteLoggerNode pNode, SMPrefs pPrefs)
  {
    super(pPrefs);
    treeTable = new RemoteLoggerTreeTable();
    treeTable.setBorder(new CompoundBorder(new EmptyBorder(2, 0, 0, 0), 
                                           treeTable.getBorder()));
    treeTable.getTreeTable().getSelectionModel()
      .addListSelectionListener(new _TreeTableSelectionListener());

    detailsPanel = new RemoteLoggerDetailsPanel();

    final AbstractFoldableSplitpane split = SplitpaneFactory
      .createSplitPane(AbstractFoldableSplitpane.TOP_TO_BOTTOM, treeTable, 
                       detailsPanel, true, true);
    split.setFoldable(IFoldableSplitpane.SECOND_FOLDABLE);
    split.setBorder(null);
    IRemoteLoggerClientConnectionManager connectionManager = pNode.getConnectionManager();
    connectionManager.addListener(new _RemoteLoggerListener());
    add(_createToolBar(connectionManager), BorderLayout.NORTH);
    add(split, BorderLayout.CENTER);
    SwingUtilities.invokeLater(() -> {
      split.setDividerLocation((int) ((split.getPreferredSize().getHeight() / 4) * 1.5));
      split.revalidate();
      split.repaint();
    });
  }

  /**
   * Erstellt die Toolbar, zum Steuern des RemoteLogger-Clients
   *
   * @param pManager  ConnectionManager zum steuern des RL-Clients
   * @return Die Toolbar-Komponente
   */
  private JToolBar _createToolBar(IRemoteLoggerClientConnectionManager pManager)
  {
    JToolBar toolbar = new JToolBar();
    toolbar.setFloatable(false);

    connectionButton = new JToggleButton(Imageloader.getInstance().loadIcon(IIcons.LINK_16))
    connectionButton.setToolTipText(Translator.getString(16, 
      IStaticResources.TEXT_CONNECT_TO_LOGGER, Locale.getDefault()));
    connectionButton.addActionListener(new _ConnectButtonListener(pManager));
    toolbar.add(connectionButton);

    JButton clearOutput = new JButton(Imageloader.getInstance().loadIcon(IIcons.TRASH_16));
    clearOutput.setToolTipText(Translator.getString(16, 
      IStaticResources.TEXT_CLEAR_OUTPUT, Locale.getDefault()));
    clearOutput.addActionListener(pEvent -> treeTable.clear());
    toolbar.add(clearOutput);

    return toolbar;
  }

  @Override
  public TableSorter getSorter()
  {
    return null;
  }

  @Override
  public JXTable getTable()
  {
    return null;
  }\end{javacode}
  \end{spacing}
\begin{spacing}{0.75}
	\begin{javacode}[firstnumber=74]
  /**
   * Implementierung eines ActionListeners der aufgerufen wird,
   * wenn der connectionButton gedrückt wird
   */
  private class _ConnectButtonListener implements ActionListener
  {
    private IRemoteLoggerClientConnectionManager connectionManager;

    public _ConnectButtonListener(IRemoteLoggerClientConnectionManager pConnectionManager)
    {
      connectionManager = pConnectionManager;
    }

    @Override
    public void actionPerformed(ActionEvent e)
    {
      try
      {
        if(e.getSource() instanceof JToggleButton)
        {
          JToggleButton button = (JToggleButton) e.getSource();
          boolean selected = button.isSelected();

          // Wieder auf dem normalzustand setzen, da wir selbst das "selected"-Flag setzen!
          button.setSelected(!selected);

          if (selected)
            connectionManager.connect(Locale.getDefault());
          else
            connectionManager.disconnect();
        }
      }
      catch (Exception ex)
      {
        CPH.checkPoint(ex, 16, 209, CPH.OK_DIALOG);
      }
    }
  }

  /**
   * Listener um auf Ausgaben und Meldungen im RemoteLogger zu hören
   */
  private class _RemoteLoggerListener implements IRemoteLoggerListener
  {
    @Override
    public void checkPointReceived(@NotNull IRemoteLoggerCheckPoint pCheckPoint)
    {
      treeTable.addCheckPoint(pCheckPoint);
    }

    @Override
    public void connectionStatusChanged(boolean pIsConnectedNow)
    {
      SwingUtilities.invokeLater(() -> connectionButton.setSelected(pIsConnectedNow));
    }
  }

  /**
   * Dieser Listener springt an, wenn sich
   * die Selektion innerhalb der TreeTable ändert
   */
  private class _TreeTableSelectionListener implements ListSelectionListener
  {
    @Override
    public void valueChanged(ListSelectionEvent e)
    {
      int selectedRow = treeTable.getTreeTable().getSelectedRow();
      if(selectedRow <= -1)
        detailsPanel.setContent(null);
      else
      {
        Object row = treeTable.getTreeTable().getModel().getValueAt(selectedRow, 0);
        if (row instanceof DefaultMutableTreeNode)
        {
          Object uo = ((DefaultMutableTreeNode) row).getUserObject()
          if (uo instanceof IRemoteLoggerCheckPoint)
            detailsPanel.setContent((IRemoteLoggerCheckPoint) uo);
        }
      }
    }
  }
}	\end{javacode}
\end{spacing}
\newpage
Detail-Panel unterhalb der TreeTable im ADITO4-Manager
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Stellt eine TextArea dar, die selbst die
 * Detailansicht eines RemoteLoggerCheckPoints
 * darstellen kann. Zeigt bspw den StackTrace eines
 * o.g. CheckPoints an
 *
 * @author W.Glanzer, 27.11.2015
 */
class RemoteLoggerDetailsPanel extends ScrollTextArea
{

  public RemoteLoggerDetailsPanel()
  {
    setBorder(null);
    setOpaque(true);
    setBackground(LfUtil.get().getGuiColors().getTaskpaneContainerColorBright());

    getTextArea().setEditable(false);
    getTextArea().setFocusable(false);
  }

  /**
   * Gibt an, welcher CheckPoint genauer angezeigt werden soll, oder <tt>null</tt>,
   * wenn die TextArea geleert werden soll
   *
   * @param pCheckPoint  CheckPoint der angezeigt werden soll, oder <tt>null</tt>
   */
  public void setContent(@Nullable IRemoteLoggerCheckPoint pCheckPoint)
  {
    String t = _toDisplayString(pCheckPoint != null ? pCheckPoint.getDetails() : null)
    getTextArea().setText(t);
    SwingUtilities.invokeLater(() -> getVerticalScrollBar().setValue(0));
  }

  /**
   * Wandelt ein StringArray in einen normalen String um
   *
   * @param pDetails  Details eines CheckPoints
   * @return Ein String, der das Detail-Array repräsentiert, nicht <tt>null</tt>
   */
  @NotNull
  private String _toDisplayString(String[] pDetails)
  {
    if(pDetails == null)
      return "";

    StringBuilder builder = new StringBuilder();
    for (String currDetail : pDetails)
      builder.append(currDetail).append('\n');
    return builder.toString();
  }
}	\end{javacode}
\end{spacing}

\vspace{10px}
TreeTable, in der die CheckPoints angezeigt werden
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Anzeige der CheckPoints in einer TreeTable
 *
 * @author W.Glanzer, 23.11.2015
 */
class RemoteLoggerTreeTable extends JPanel
{
  private final SplitsTreeTable treeTable;
  private final RemoteLoggerTableModel model = new RemoteLoggerTableModel();

  public RemoteLoggerTreeTable()
  {
    setLayout(new BorderLayout());
    treeTable = new SplitsTreeTable(DefaultOutlineModel.createOutlineModel(model, model, 
     true, Translator.getString(16, IStaticResources.TEXT_TIMESTAMP, Locale.getDefault())));
    
    treeTable.setRootVisible(false);
    treeTable.setRenderDataProvider(new RemoteLoggerTreeDataProvider());
    treeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    treeTable.setDefaultRenderer(IRemoteLoggerCheckPoint.class, 
      new RemoteLoggerTreeTableCheckPointRenderer());\end{javacode}
              \end{spacing}
            \begin{spacing}{0.75}
            	\begin{javacode}[firstnumber=22]
    for (TableColumn currColumn : treeTable.getColumns())
    {
      int currIndex = treeTable.getColumnModel().getColumnIndex(currColumn.getIdentifier());
      if(currIndex == 0)
        currColumn.setPreferredWidth(150);
      else if(currIndex == 1)
        currColumn.setPreferredWidth(90);
      else
        currColumn.setPreferredWidth(300);
    }

    treeTable.addFocusListener(new FocusAdapter()
    {
      @Override
      public void focusLost(FocusEvent e)
      {
        // Beim wechsel des Fokus ist ein behalten der Selektion verwirrend
        treeTable.clearSelection();
      }
    });

    SwingUtilities.invokeLater(() -> {
      add(treeTable.getTableHeader(), BorderLayout.NORTH);
      add(new AutoScrollDownScrollPane(treeTable, true), BorderLayout.CENTER);
    });
  }
  
  /**
   * Fügt dem Model einen CheckPoint hinzu
   *
   * @param pCheckPoint CheckPoint, der hinzugefügt werden soll, nicht
   *                    <tt>null</tt>, da das keinen Sinn machen würde!
   */
  public void addCheckPoint(@NotNull IRemoteLoggerCheckPoint pCheckPoint)
  {
    // Alle derzeit expandierten Pfade merken
    TreePathSupport tpSupport = treeTable.getOutlineModel().getTreePathSupport();
    TreePath[] allExpandeds = tpSupport.getExpandedDescendants(new TreePath(model.getRoot()));

    // derzeit selektierte Zeile speichern
    int selectedRow = treeTable.getSelectedRow();

    // Dem Model einen neuen CheckPoint hinzufügen
    model.addCheckPoint(pCheckPoint);

    // expandierte Pfade wieder expandieren
    for (TreePath currPath : allExpandeds)
      tpSupport.expandPath(currPath);

    // selektiert die davor gespeicherte Zeile wieder
    if(selectedRow > -1)
      treeTable.setRowSelectionInterval(selectedRow, selectedRow);

    SwingUtilities.invokeLater(() -> {
      revalidate();
      repaint();
    });
  }

  /**
   * Leert das Ausgabefenster
   */
  public void clear()
  {
    model.clear();

    SwingUtilities.invokeLater(() -> {
      treeTable.revalidate();
      treeTable.repaint();
      revalidate();
      repaint();
    });
  }

  /**
   * @return Die konkrete Instanz der dahinterliegenden TreeTable
   */
  public SplitsTreeTable getTreeTable()
  {
    return treeTable;
  }
}\end{javacode}
\end{spacing}

Model, das die Daten für die Tabelle der o.g. TreeTable liefert
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Model der RemoteLoggerTreeTable, zur Visualisierung von CheckPoints.
 * Stellt das Model der rechts-liegenden Tabelle dar (2. Teil der TreeTable)
 *
 * @see RemoteLoggerTreeDataProvider
 * @see RemoteLoggerTreeTable
 * @author W.Glanzer, 24.11.2015
 */
class RemoteLoggerTableModel extends DefaultTreeModel implements RowModel
{
  private final DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode();

  public RemoteLoggerTableModel()
  {
    super(null);
    setRoot(rootNode);
  }

  /**
   * Fügt einen CheckPoint in das Model ein und lädt das Model neu
   *
   * @param pCheckPoint CheckPoint, der hinzugefügt werden soll, nicht <tt>null</tt>!
   */
  public void addCheckPoint(@NotNull IRemoteLoggerCheckPoint pCheckPoint)
  {
    rootNode.add(_toNode(pCheckPoint));
    reload(rootNode);
  }

  @Override
  public int getColumnCount()
  {
    return 2; //+1 Tree-Spalte
  }

  @Override
  public Object getValueFor(Object node, int column)
  {
    return node;
  }

  @Override
  public Class getColumnClass(int column)
  {
    return IRemoteLoggerCheckPoint.class;
  }

  @Override
  public boolean isCellEditable(Object node, int column)
  {
    // Generell keine Editiermöglichkeit erlaubt!
    return false;
  }

  @Override
  public void setValueFor(Object node, int column, Object value)
  {
    // Generell keine Editiermöglichkeit erlaubt!
  }

  @Override
  public String getColumnName(int column)
  {
    switch(column)
    {
      case 0:
        return Translator.getString(16, IStaticResources.TEXT_IDENTIFICATION, 
                                     Locale.getDefault());

      case 1:
        return Translator.getString(16, IStaticResources.TEXT_MESSAGE, 
                                     Locale.getDefault());

      default:
        return null;
    }
  }\end{javacode}
                \end{spacing}
              \begin{spacing}{0.75}
              	\begin{javacode}[firstnumber=78]
  /**
   * Leert alle Einträge in der RootNode --> Keine LogAusgaben mehr angezeigt
   */
  public void clear()
  {
    rootNode.removeAllChildren();
    reload(rootNode);
  }

  /**
   * Wandelt einen CheckPoint in eine darstellbare TreeNode um
   *
   * @param pCheckPoint  CheckPoint, der umgewandelt werden soll
   * @return TreeNode, die angezeigt werden kann und die Baumstruktur darstellt
   */
  private MutableTreeNode _toNode(IRemoteLoggerCheckPoint pCheckPoint)
  {
    DefaultMutableTreeNode node = new DefaultMutableTreeNode(pCheckPoint);
    if(pCheckPoint.getCause() != null)
      node.add(_toNode(pCheckPoint.getCause()));
    return node;
  }

}\end{javacode}
\end{spacing}

\vspace{10px}
Modell, das die Daten für den Baum der o.g. TreeTable liefert
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Stellt die Daten für den Tree der TreeTable bereit
 *
 * @author W.Glanzer, 24.11.2015
 */
class RemoteLoggerTreeDataProvider implements RenderDataProvider
{

  @Override
  public String getDisplayName(Object pNode)
  {
    IRemoteLoggerCheckPoint checkPoint = _toCP(pNode);
    if(checkPoint != null)
      return DateUtility.dateToISO8601(new Date(checkPoint.getTime()), DateUtility.UTC);

    return String.valueOf(pNode);
  }

  @Override
  public String getTooltipText(Object pNode)
  {
    return null;
  }

  @Override
  public boolean isHtmlDisplayName(Object pNode)
  {
    return false;
  }

  @Override
  public Color getBackground(Object pNode)
  {
    return null;
  }
  
  @Override
  public Color getForeground(Object pNode)
  {
    IRemoteLoggerCheckPoint checkPoint = _toCP(pNode);
    if(checkPoint != null)
    {
      IGuiColors colors = LfUtil.get().getGuiColors();
      return CheckPointUtility.getColor(checkPoint.getPriority(), colors.getErrorColor(),
        colors.getWarningColor(), colors.getInfoColor());
    }

    return null;
  }\end{javacode}
    \end{spacing}
  \begin{spacing}{0.75}
  	\begin{javacode}
  @Override
  public Icon getIcon(Object pNode)
  {
    // Kein Icon, auch kein standardicon!
    return new EmptyIcon(0, 0);
  }

  /**
   * Wandelt ein Object in einen RemoteLoggerCheckPoint um, wenn dies funktioniert
   *
   * @param pNode  Object, das umgewandelt werden soll
   * @return Einen RemoteLoggerCheckPoint, oder <tt>null</tt>, wenn es nicht möglich war
   */
  private IRemoteLoggerCheckPoint _toCP(Object pNode)
  {
    if(pNode instanceof DefaultMutableTreeNode)
    {
      Object obj = ((DefaultMutableTreeNode) pNode).getUserObject();
      if (obj instanceof IRemoteLoggerCheckPoint)
        return (IRemoteLoggerCheckPoint) obj;
    }

    return null;
  }
}\end{javacode}
\end{spacing}

\vspace{10px}
Rendert die CheckPoints innerhalb der o.g. TreeTable
\begin{spacing}{0.75}
	\begin{javacode}
/**
 * Rendert einen CheckPoint in der TreeTable (rechten Tabelle)
 *
 * @author W.Glanzer, 24.11.2015
 */
class RemoteLoggerTreeTableCheckPointRenderer extends DefaultOutlineCellRenderer
{

  @Override
  public Component getTableCellRendererComponent(JTable pTable, Object pValue, 
    boolean pIsSelected, boolean pHasFocus, int pRow, int pColumn)
  {
    super.getTableCellRendererComponent(pTable, pValue, pIsSelected, false, pRow, pColumn);
    if(pValue instanceof DefaultMutableTreeNode && 
      ((DefaultMutableTreeNode) pValue).getUserObject() instanceof IRemoteLoggerCheckPoint)
    {
      DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode) pValue
      IRemoteLoggerCheckPoint checkPoint = (IRemoteLoggerCheckPoint) dmtn.getUserObject();

      // Sonst würde die weiße Vordergrundfarbe überschrieben 
      // --> Schlecht leesbar, wenn selektiert
      if(!pIsSelected)
      {
        IGuiColors colors = LfUtil.get().getGuiColors();
        setForeground(CheckPointUtility.getColor(checkPoint.getPriority(), 
          colors.getErrorColor(), colors.getWarningColor(), colors.getInfoColor()));
      }

      switch (pColumn)
      {
        case 1:
          setText(_getID(checkPoint));
          break;

        case 2:
          setText(_getMessage(checkPoint));
          break;
      }
    }

    return this;
  } \end{javacode}
\end{spacing}
\begin{spacing}{0.75}
  	\begin{javacode}
  /**
   * Liefert den Identifier des CheckPoints
   *
   * @param pCheckPoint  CheckPoint, dessen ID gesucht ist
   * @return ID als String
   */
  private String _getID(IRemoteLoggerCheckPoint pCheckPoint)
  {
    return CheckPointUtility.getErrorCode(pCheckPoint.getKind(), pCheckPoint.getModule(),
      pCheckPoint.getPriority(), pCheckPoint.getID(), pCheckPoint.getProgram());
  }

  /**
   * Liefert die zusammengesetzte Nachricht des CheckPoints.
   * Diese setzt sich aus der originalen Message und der Details zusammen
   *
   * @param pCheckPoint  CheckPoint, dessen Nachricht ausgelesen werden soll
   * @return Message + Details als einzelner String
   */
  private String _getMessage(IRemoteLoggerCheckPoint pCheckPoint)
  {
    return pCheckPoint.getMessage();
  }

}	\end{javacode}
\end{spacing}