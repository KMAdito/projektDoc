\begin{Verbatim}[commandchars=\\\{\},codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}]
\PYG{c+cm}{/**}
\PYG{c+cm}{ * Logger, der Checkpoints zu verbunden RemoteLogger-Instanzen senden kann}
\PYG{c+cm}{ *}
\PYG{c+cm}{ * @author W.Glanzer, 18.11.2015}
\PYG{c+cm}{ */}
\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{RemoteLogger} \PYG{k+kd}{extends} \PYG{n}{AbstractLogger}
\PYG{o}{\PYGZob{}}
  \PYG{k+kd}{private} \PYG{n}{IRemoteLoggerConnectionHandler} \PYG{n}{connectionHandler}\PYG{o}{;}

  \PYG{k+kd}{private} \PYG{k+kt}{boolean} \PYG{n}{failed} \PYG{o}{=} \PYG{k+kc}{false}\PYG{o}{;}
  \PYG{k+kd}{private} \PYG{n}{Exception} \PYG{n}{failedEx} \PYG{o}{=} \PYG{k+kc}{null}\PYG{o}{;}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * Erzeugt einen neuen RemoteLogger}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @param pPriority                die Priorität des Loggers}
\PYG{c+cm}{   * @param pAddress                 die Addresse des Listeners}
\PYG{c+cm}{   * @param pPort                    der Port des Listeners}
\PYG{c+cm}{   * @param pRemoteLoggerLoginFacade Facade zum einloggen von RemoteLogger-Clients}
\PYG{c+cm}{   *                                 am RemoteLogger-Server, oder <tt>null</tt> wenn}
\PYG{c+cm}{   *                                 generell alle Clients erlaubt sind}
\PYG{c+cm}{   */}
  \PYG{k+kd}{public} \PYG{n+nf}{RemoteLogger}\PYG{o}{(}\PYG{k+kt}{char} \PYG{n}{pPriority}\PYG{o}{,} \PYG{n}{String} \PYG{n}{pAddress}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{pPort}\PYG{o}{,}
    \PYG{n+nd}{@Nullable} \PYG{n}{Supplier}\PYG{o}{\PYGZlt{}}\PYG{n}{IRemoteLoggerLoginFacade}\PYG{o}{\PYGZgt{}} \PYG{n}{pRemoteLoggerLoginFacade}\PYG{o}{)}
  \PYG{o}{\PYGZob{}}
    \PYG{k}{try}
    \PYG{o}{\PYGZob{}}
      \PYG{n}{IRemoteLoggerCommandHandlerRegistry} \PYG{n}{commandRegistry} \PYG{o}{=}
        \PYG{k}{new} \PYG{n}{MapRemoteLoggerCommandHandlerRegistry}\PYG{o}{();}
      \PYG{n}{commandRegistry}\PYG{o}{.}\PYG{n+na}{addHandler}\PYG{o}{(}\PYG{n}{IRemoteLoggerCommand}\PYG{o}{.}\PYG{n+na}{Type}\PYG{o}{.}\PYG{n+na}{AUTHORIZE}\PYG{o}{,}
        \PYG{k}{new} \PYG{n}{AuthorizationCommandHandler}\PYG{o}{(}\PYG{n}{pRemoteLoggerLoginFacade}\PYG{o}{));}
      \PYG{n}{commandRegistry}\PYG{o}{.}\PYG{n+na}{addHandler}\PYG{o}{(}\PYG{n}{IRemoteLoggerCommand}\PYG{o}{.}\PYG{n+na}{Type}\PYG{o}{.}\PYG{n+na}{LANGUAGE}\PYG{o}{,}
        \PYG{k}{new} \PYG{n}{LanguageCommandHandler}\PYG{o}{());}

      \PYG{n}{RemoteLoggerInstanceManager} \PYG{n}{im} \PYG{o}{=} \PYG{n}{RemoteLoggerInstanceManager}\PYG{o}{.}\PYG{n+na}{getInstance}\PYG{o}{();}
      \PYG{n}{connectionHandler} \PYG{o}{=} \PYG{n}{im}\PYG{o}{.}\PYG{n+na}{getConnectionHandler}\PYG{o}{(}\PYG{n}{pAddress}\PYG{o}{,} \PYG{n}{pPort}\PYG{o}{);}
      \PYG{n}{connectionHandler}\PYG{o}{.}\PYG{n+na}{setCommandRegistry}\PYG{o}{(}\PYG{n}{commandRegistry}\PYG{o}{);}
      \PYG{n}{setPriority}\PYG{o}{(}\PYG{n}{pPriority}\PYG{o}{);}
    \PYG{o}{\PYGZcb{}}
    \PYG{k}{catch} \PYG{o}{(}\PYG{n}{Exception} \PYG{n}{ex}\PYG{o}{)}
    \PYG{o}{\PYGZob{}}
      \PYG{n}{System}\PYG{o}{.}\PYG{n+na}{err}\PYG{o}{.}\PYG{n+na}{println}\PYG{o}{(}\PYG{l+s}{\PYGZdq{}RemoteLogger failed:\PYGZdq{}}\PYG{o}{);}
      \PYG{n}{ex}\PYG{o}{.}\PYG{n+na}{printStackTrace}\PYG{o}{();}

      \PYG{n}{failed} \PYG{o}{=} \PYG{k+kc}{true}\PYG{o}{;}
      \PYG{n}{failedEx} \PYG{o}{=} \PYG{n}{ex}\PYG{o}{;}
    \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * Hier kann der Logger einen Selbsttest machen. Schlägt dieser fehl}
\PYG{c+cm}{   * kann er eine neuen Fehler erzeugen damit andere Logger dies melden können.}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @return <tt>true</tt> wenn der Logger funktioniert, andernfalls <tt>false</tt>}
\PYG{c+cm}{   */}
  \PYG{k+kd}{public} \PYG{k+kt}{boolean} \PYG{n+nf}{checkFunction}\PYG{o}{()}
  \PYG{o}{\PYGZob{}}
    \PYG{c+c1}{// Neuen Wert berechnen}
    \PYG{n}{failed} \PYG{o}{=} \PYG{n}{failed} \PYG{o}{||} \PYG{n}{connectionHandler}\PYG{o}{.}\PYG{n+na}{hasFailed}\PYG{o}{();}

    \PYG{k}{if} \PYG{o}{(}\PYG{n}{failed}\PYG{o}{)}
    \PYG{o}{\PYGZob{}}
      \PYG{n}{AditoException} \PYG{n}{ex} \PYG{o}{=} \PYG{k}{new} \PYG{n}{AditoException}\PYG{o}{(}\PYG{n}{failedEx}\PYG{o}{,} \PYG{l+m+mi}{0}\PYG{o}{,} \PYG{l+m+mi}{32}\PYG{o}{);}
      \PYG{n}{CPH}\PYG{o}{.}\PYG{n+na}{checkPoint}\PYG{o}{(}\PYG{n}{ex}\PYG{o}{);}
    \PYG{o}{\PYGZcb{}}

    \PYG{k}{return} \PYG{o}{!}\PYG{n}{failed}\PYG{o}{;}
  \PYG{o}{\PYGZcb{}}

  \PYG{c+cm}{/**}
\PYG{c+cm}{   * Loggt einen Checkpoint}
\PYG{c+cm}{   *}
\PYG{c+cm}{   * @param pError der Checkpoint}
\PYG{c+cm}{   * @param pTime  die Zeit, wann er aufgetreten ist}
\PYG{c+cm}{   */}
  \PYG{k+kd}{public} \PYG{k+kt}{void} \PYG{n+nf}{logError}\PYG{o}{(}\PYG{n}{CheckPoint}\PYG{o}{[]} \PYG{n}{pError}\PYG{o}{,} \PYG{k+kt}{long} \PYG{n}{pTime}\PYG{o}{)}
  \PYG{o}{\PYGZob{}}
\end{Verbatim}
