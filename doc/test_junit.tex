\section{Anwendungstests}
\par Da das Projekt im Wasserfallmodell entwickelt wurde, fand gegen Ende ein umfangreiches Testen aller Teilmodule des Loggers statt. Getestet wurde mit dem Java-Framework \glqq JUnit\grqq.
\par JUnit ist ein einfaches, quelloffenes Framework zum Testen von Java-Programmen, das besonders für das automatisierte Testen einzelner Module geeignet ist. Es bietet ebenso ein leicht integrierbares Maven-Plugin, wodurch es sich perfekt in den Build-Vorgang von ADITO einfügt. Dieses Plugin führt alle vorhandenen Tests automatisch bei einem Kompiliervorgang mit Maven aus. Dadurch fallen etwaige Programmierfehler sehr früh auf und können schon bei der Implementierung behoben werden.
\par Der JUnit-Test des Remote-Loggers ist in drei Teile unterteilt:

\par \textit{\underline{Initialisierung der Testkomponenten, (@Before)}}
\vspace{8px}
\input{CODE/CODE_TestRemoteLogger_init.tex}
In der \glqq init()\grqq-Methode wird anfangs der Remote-Logger-Server mit der niedrigsten Priorität (Z) initialisiert. Ebenso wird die Adresse (localhost, Port 7733) bestimmt, auf die der Remote-Logger-Server hören soll.

\vspace{10px}
\input{CODE/CODE_TestRemoteLogger_DummyFacade.tex}
Um den korrekten Login eines Remote-Logger-Clients am Remote-Logger-Server zu testen wird eine spezielle Implementierung des Interfaces \glqq IRemoteLoggerLoginFacade\grqq\ (siehe \prettyref{sec:IRemoteLoggerLoginFacade}) benötigt. Diese soll einen Verbindungsaufbau des Clients nur zulassen, wenn die empfangenen Login-Informationen \glqq USER\grqq\ und \glqq PASS\grqq\ enthalten. Das stellt eine Anmeldung mit Benutzername und Passwort dar.

\vspace{5px}
\par \textit{\underline{Hauptteil, (@Test)}}
\par Im Hauptteil des JUnit-Tests, repräsentiert durch die \glqq test\_communication()\grqq-Methode, wird die Funktionalität des Remote-Loggers auf die Probe gestellt. \\
Kurz zusammengefasst: Es werden zwei Remote-Logger-Clients erzeugt. Diese verbinden sich mit dem vorher initialisierten Remote-Logger-Server und erhalten CheckPoints. Das Auswerten empfangener Meldungen übernimmt die JUnit-Klasse \glqq Assert\grqq. 

\par Die genaue Funktionsweise wird im Nachfolgenden erklärt:

\input{CODE/CODE_TestRemoteLogger-test_communication-ConnectionManager.tex}
\par Zu Anfang werden zwei Remote-Logger-Clients mit unterschiedlicher Sprache gestartet. Dafür wird eine Implementierung des Interfaces \grqq\ IRemoteLogger-ClientConnectionManager\grqq \\ benötigt, welche durch die Subklasse \glqq \_ConnectionManager\grqq\ (\prettyref{fig:CODE_TestRemoteLogger-test_communication-ConnectionManager}) abgebildet ist. 
Diese enhält passenden Login-Informationen und die Verbindungsparameter, um sich erfolgreich mit dem vorher gestarteten Remote-Logger-Server zu verbinden. 

\input{CODE/CODE_TestRemoteLogger-test_communication-RemoteListener.tex}
Um auf Ereignisse des Remote-Logger-Servers zu reagieren, wird pro Remote-Logger-Client eine neue Instanz des Listeners \glqq \_RemoteListener\grqq\ erzeugt und registriert. Dieser speichert empfangene CheckPoints in einer im Konstruktor übergebenen AtomicReference (\glqq refToSet\grqq) und benachrichtigt anschließend alle Threads, die auf das Setzen dieser Referenz warten.

\input{CODE/CODE_TestRemoteLogger-test_communication-sendReceiveCP.tex} Nachdem die Remote-Logger-Clients mit dem Remote-Logger-Server erfolgreich verbunden sind kann nun begonnen werden, CheckPoints zu senden. Hierzu wird der bereits vorhandene, ADITO4-eigene, \glqq CheckPointHandler\grqq\ verwendet, der systemweit alle aufgetretenen CheckPoints an vorhandene Loggerimplementierungen übergibt. 

\input{CODE/CODE_TestRemoteLogger-getNextCheckPoint.tex}
Anschließend wird mit Hilfe der Methode \glqq \_getNextCheckPoint(...)\grqq\ der zuletzt empfangene CheckPoint ausgelesen. Die übergebene AtomicReference dient hierfür als Container. Ist bereits ein Wert innerhalb dieses Containers gespeichert, dann wird dieser ausgelesen und zurückgegeben. Falls nicht wird so lange gewartet, bis der aktuelle Thread über das AtomicReference-Objekt benachrichtigt wird. Das Benachrichtigen erfolgt durch die Methode \glqq notifyAll()\grqq, die in der \glqq checkPointReceived(...)\grqq-Methode des registrierten Remote-Logger-Listeners aufgerufen wird (siehe \prettyref{fig:CODE_TestRemoteLogger-test_communication-RemoteListener}).
Anschließend werden die Werte des empfangenen, deutschen CheckPoints auf Richtigkeit geprüft. Falls hierbei kein Fehler aufgetreten ist, wird der englische CheckPoint mit dem gleichen Verfahren überprüft. Hierfür muss nur die dahinterliegende Nachricht angepasst werden, denn ID, Modulnr., Programmnr., Typ und Priorität bleiben selbstverständlich gleich.
\input{CODE/CODE_TestRemoteLogger-checkCheckPoint.tex}

\vspace{5px}
\par \textit{\underline{Aufräumen der benutzen Komponenten, (@After)}}
\par Am Ende muss der Logger noch aufgeräumt werden, da sonst in manchen Fällen der Java-Socket nicht beendet wird und der Port (7733) blockiert bleiben würde.