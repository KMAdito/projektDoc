\section{Implementierung}

\subsection{GUI Komponenten}

Da die Hauptaufgabe dieser Projektarbeit darin bestand, die benötigten GUI Komponenten zu entwickeln und in richtiger Weise zusammenzusetzen, wird darauf im folgenden detailliert eingegangen.

\subsubsection{ShortcutField}

Ein \textbf{ShortcutField} ist -- wie in Abschnitt \ref{ui} bereits erwähnt -- für die Anzeige und Bearbeitung von Tastaturkürzeln zuständig. Sofern noch kein Shortcut eingegeben wurde, zeigt sie zudem eine Aufforderung zum Eingeben eines Shortcuts in Form eines Texts an (\glqq enter shortcut...\grqq). Um diesen Anforderungen gerecht zu werden, setzt sie sich aus drei bereits bestehenden Komponenten zusammen: Für das Löschen des gesamten Shortcuts dient ein \textbf{CrossButton} (umkreistes Kreuz), für die Anzeige und Bearbeitung des Shortcuts kommt die \textbf{ShortcutView}-Komponente zum Einsatz und die Textaufforderung wird durch ein \textbf{JLabel} realisiert.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{../graphic/diagrams/CD_ShortcutField/ShortcutField}
	\caption{ShortcutField}
	\label{fig:shortcutfield}
\end{figure}

Die eigentliche Funktionalität wird durch die verwendeten Komponenten bereitgestellt. Selbst kümmert sich das \textbf{ShortcutField} um die Anzeige der jeweils richtigen Komponente (\textbf{JLabel} oder \textbf{ShortcutView}), sowie um das Horchen auf Tastatureingaben mittels eines \textbf{KeyListeners}. Die private Methode \textbf{\_update()} ist für das Ein- und Ausblenden der jeweiligen Komponente zuständig (siehe \autoref{fig:ShortcutField-update}). Sie wird initial und bei jeder Änderung des Shortcuts aufgerufen.

\vspace{20px}

\input{CODE/ShortcutField-update}

Zunächst wird überprüft, ob das \textbf{ShortcutField} leer ist (kein Shortcut gesetzt). Das Ergebnis dieser Überprüfung wird in der lokalen Variable \textbf{empty} gespeichert. Anschließend werden die Sichtbarkeiten der Komponenten aktualisiert, wobei der \textbf{ShortcutViewer} nur bei gesetztem und die Textaufforderung nur bei nicht gesetztem Tastenkürzel angezeigt wird. Der \textbf{CrossButton} wird im Editiermodus immer angezeigt aber nur aktiviert, sobald ein Shortcut eingegeben wird.

\newpage

\subsubsection{Check-Button}

\vspace{-3px}

Um die Grundfunktionalität des im Abschnitt \ref{ui} erwähnten Check-Buttons zu definieren, wurde zunächst das Interface \textbf{ICheckComponent} erstellt. Indessen wird festgelegt, dass ein Check-Button einen Checked-Zustand besitzt, welcher angibt, ob innerhalb der Komponente ein grüner Haken (\textbf{true}) oder ein rotes Kreuz (\textbf{false}) angezeigt werden soll (siehe \autoref{fig:cdcheckbutton}).

Die Klasse \textbf{CheckToggleButton} implementiert das beschriebene Interface und erbt von der Swing Klasse \textbf{JToggleButton}. Sie kümmert sich um das Einfügen und Aktualisieren des richtigen Symbols. Innerhalb von \textbf{setChecked(...)} wird die private Methode \textbf{\_updateIcon()} aufgerufen, welche ihrerseits das jeweilige Symbol über das gesetzte Icon zeichnet (siehe Anhang \ref{CheckToggleButton}). Insgesamt stellt ein \textbf{CheckToggleButton} eine vollwertige CheckComponent dar, welche direkt verwendet werden könnte.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{../graphic/diagrams/CD_CheckButton/CD_CheckButton}
	\caption{CheckItemButton}
	\label{fig:cdcheckbutton}
\end{figure}

\vspace{-9px}

Um die Benutzung von \textbf{CheckToggleButtons} innerhalb des Shortcut Editors bzw. im Zusammenhang mit \textbf{ICheckItems} einfacher zu gestalten, wurde die Klasse \textbf{CheckItemButton} eingeführt. Diese erweitet \textbf{CheckToggleButton} und kann über den Konstruktor ein \textbf{ICheckItem} aufnehmen. Wie im Anhang \ref{CheckItemButton} ersichtlich, werden innerhalb dieses Konstruktors alle Eigenschaften entsprechend dem \textbf{ICheckItem} gesetzt (z.B. Checked-Zustand oder Icon).

\vspace{-9px}

\subsubsection{CheckItemContainer}

\vspace{-3px}

\begin{wrapfigure}[15]{r}[0cm]{165px}
	\vspace{-12px}
	\centering
	\includegraphics[width=.95\linewidth]{../graphic/diagrams/CD_CheckItemContainer/CD_CheckItemContainer}
	\caption{CheckItemContainer}
	\label{fig:cdcheckitemcontainer}
\end{wrapfigure}

Der Designentwurf lässt erkennen, dass die Check-Buttons einer bestimmten Positionierung bzw. Sortierung unterliegen: auf der linken Seite befinden sich alle unchecked und auf der rechten Seite alle checked Buttons. Zudem wird bei Browser-Check-Buttons ein Abstand zwischen den beiden Buttongruppen eingefügt. 

Um diese Positionierung zu realisieren, wurde der \textbf{CheckButtonContainer} erstellt. Dieser stellt eine \textbf{JComponent} dar, welcher mittels eines \textbf{BoxLayouts} seine CheckButtons horizontal nebeneinander ausrichtet. Um den zuvor erwähnten Abstand ein- und auszuschalten, existiert die Methode \textbf{setSplitting(...)}, welche einen \textbf{boolean} erwartet. Ändert sich der Checked-Zustand eines CheckButtons, so kümmert sich der Container auch um die richtige Umsortierung.

Um wiederum die Nutzung innerhalb des Shortcut Editors zu erleichtern, existiert der \textbf{CheckItemContainer}. Diesem kann man CheckItems setzten (\textbf{setCheckItems(...)}), wonach dieser intern die benötigten Check-Buttons erzeugt und sich selbst hinzufügt oder Unnötige wieder entfernt (siehe Anhang \ref{CheckItemContainer}). Zudem kann über die Methode \textbf{getSelection()} der aktuell selektierte Check-Button ausgelesen werden.

\subsubsection{CheckItemAccordion}

\vspace{-8px}

Die Accordion-Komponente ist in der Lage, einen konkreten Pfad des Datenmodells für Browsertestergebnisse mit allen verfügbaren Details darzustellen (siehe \autoref{fig:uxDesigns}).
Jede Sektion des Accordions visualisiert genau ein CheckItem. Sofern Untersektionen vorhanden sind, wird zusätzlich ein CheckItemContainer angezeigt. Dieser dient zur Navigation durch das Datenmodell, wobei immer genau das CheckItem dargestellt wird, welches in der vorherigen Sektion ausgewählt ist.

\begin{wrapfigure}[11]{l}[0cm]{230px}
	\vspace{-12px}
	\centering
	\includegraphics[width=0.95\linewidth]{../graphic/diagrams/CD_CheckItemAccordion/CheckItemAccordion}
	\caption{CheckItemAccordion}
	\label{fig:checkitemaccordion}
\end{wrapfigure}


Das \textbf{CheckItemAccordion} erbt von der Swing Klasse \textbf{JPanel} (siehe \autoref{fig:checkitemaccordion}) und verwendet zur vertikalen Positionierung der einzelnen Sektionen das \textbf{BoxLayout}. Im Konstruktor wird der oberste \textbf{CheckItemContainer} erzeugt, welcher zur Auswahl des Browsers dient und sich nicht innerhalb des Accordions befindet (siehe \autoref{fig:uxDesigns}). Um auf diesen außerhalb zugreifen zu können, dient die Methode \textbf{getRootCheckItemContainer()}.

Eine Sektion wird durch die Klasse \textbf{CheckItemViewer} repräsentiert (siehe \autoref{fig:checkitemaccordion}). Diese Komponente besitzt die Fähigkeit alle Details eines CheckItems in tabellarischer Form darzustellen. Sie erbt von \textbf{ExpandComponent}, wodurch die Funktion des Ein- und Ausklappens und die Anzeige einer Header-Leiste ermöglicht wird. Damit das selektierte \textbf{CheckItem} des vorherigen \textbf{CheckItemViewers} angezeigt und auf Selektionsänderungen reagiert werden kann, wird im Konstruktor der vorherige \textbf{CheckItemContainer} übergeben. Diesem wird ein Listener hinzugefügt, welcher auf Änderungen der Selektion horcht und so die Aktualisierung des Viewers ermöglicht.

\input{CODE/CheckItemAccordion-setCheckItemGroup}

In \autoref{fig:CheckItemAccordion-setCheckItemGroup} ist der Sourcecode der Methode \textbf{setCheckItemGroup(...)} abgebildet. In dieser wird anhand der übergebenen \textbf{ICheckItemGroup} das Accordion aufgebaut. Zu Beginn wird überprüft, ob es sich bei der übergebenen Gruppe um die bereits gesetzte handelt. Ist dies der Fall, so wird die Methode ohne Änderungen verlassen. Andernfalls werden dem RootCheckItemContainer die CheckItems der RootGruppe (Browser Check-Items) gesetzt. Anschließend wird über die Methode \textbf{\_getMaxDept(...)} die maximale Tiefe der Baumstruktur von \textbf{pRootGroup} ermittelt. Dieses Ergebnis dient als Grundlage für die Anzahl von Sektionen, die eingefügt werden. Nach dem Löschen aller vorhandenen Komponenten, wird in jedem Schleifendurchgang eine Sektion eingefügt. Dabei wird im Konstruktor des \textbf{CheckItemViewers} immer der \textbf{CheckItemContainer} der vorherigen Sektion oder am Anfang der \textbf{rootCheckItemContainer} übergeben. Dadurch wird der richtige Zusammenhang zwischen den Sektionen hergestellt.

\subsubsection{BreadCrumb und TreeTable}

Die Komponenten BreadCrumb und TreeTable mussten im Zuge dieser Projektarbeit nicht neu entwickelt werden, da sie bereits zu einem früheren Zeitpunkt umgesetz wurden. 

\begin{wrapfigure}[12]{l}[0cm]{230px}
	\vspace{-12px}
	\centering
	\includegraphics[width=1\linewidth]{../graphic/diagrams/CD_IShortcutStructureView/IShortcutStructureView}
	\caption{IShortcutStructureView}
	\label{fig:ishortcutstructureview}
\end{wrapfigure}

Um sie jedoch im Zusammenhang mit dem MVP-Architekturmuster verwenden zu können, mussten sie in eigene Klassen gekapselt werden, welche \textbf{IShortcutStructureView} (siehe \autoref{fig:ishortcutstructureview}) implementieren. Dazu wurden die Klassen \textbf{ShortcutPathComponent} (BreadCrumb) und \textbf{ShortcutStructureTable} (TreeTable) erstellt (siehe Anhang \ref{ShortcutStructureTable} und \ref{ShortcutPathComponent}). Über die im Interface enthaltenen Methoden erhält die jeweilige Komponente ihre Informationen, welche zur Darstellung benötigt werden. Außerdem erhält sie die Möglichkeit Wertänderungen über Listener zu kommunizieren. Wählt der Benutzer beispielsweise einen anderen Knoten in der BreadCrumb aus, so werden alle hinzugefügten \textbf{PathChangeListener} informiert.


\subsubsection{ShortcutEditorUI}

Nach der Implementierung der einzelenen Komponenten, mussten diese zu einem gesamten User Interface zusammengesetzt werden. Hierzu wurde die Klasse \textbf{ShortcutEditorUI} (siehe Anhang \ref{ShortcutEditorUI}) erstellt. Sie implementiert das Interface \textbf{IShortcutEditorUI}, welches wiederum von \textbf{IShortcutStructureView} erbt. Zudem erbt die UI von der Swing Klasse \textbf{JPanel} (\autoref{fig:shortcuteditorui}).

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{../graphic/diagrams/CD_ShortcutEditorUI/ShortcutEditorUI}
	\caption{ShortcutEditorUI}
	\label{fig:shortcuteditorui}
\end{figure} 

\vspace{-12px}

Zur Anordnung der einzelnen Komponenten kommt das \textbf{TableLayout} zum Einsatz. Im Konstruktor der Klasse werden die Spalten- und Zeilenausdehnungen des Layouts definiert und die Komponenten in die entsprechenden Zellen eingefügt. Außerdem wird das \textbf{ShortcutStructureModel} und der \textbf{ShortcutStructurePresenter} initialisiert. 

Da die Funktionalität in den für die UI verwendeten Komponenten enthalten ist, werden alle Getter- und Setter-Anfragen sowie die Listener direkt an das entsprechende Element (Komponente oder Model) weitergeleitet. In der \textbf{setShortcut(...)} Methode der ShortcutEditorUI wird beispielsweise sofort die \textbf{setShortcut(...)} Methode des ShortcutFields aufgerufen und so der zu setzende Shortcut direkt weitergegeben.

\newpage

\subsection{Presenter}

Folgend wird die Implementierung der im Abschnitt \ref{Architekturdesign} beschiebenen Presenter erläutert.

\subsubsection{ShortcutEditorPresenter}

\begin{wrapfigure}[11]{r}[0cm]{230px}
	\vspace{-12px}
	\centering
	\includegraphics[width=230px]{../graphic/diagrams/CD_ShortcutEditorPresenter/ShortcutEditorPresenter}
	\caption{ShortcutEditorPresenter}
	\label{fig:shortcuteditorpresenter}
\end{wrapfigure}

Um die Daten der \textbf{ShortcutEditorUI} mit den in Abschnitten \ref{DatenmodellFunc} und \ref{DatenmodellBrow} beschriebenen Datenmodellen abzugleichen, existiert gemäß des MVP-Architekturmusters der \textbf{ShortcutEditorPresenter} (siehe Anhang \ref{ShortcutEditorPresenter}). Diesem wird über den Konstruktor sowohl der Datenstore als auch eine \textbf{IShortcutEditorUI} übergeben. Anschließend werden der UI Listener hinzugefügt, welche auf Shortcut- und Pfadänderungen horchen.

Ändert der Benutzer über die UI den Shortcut, so wird dieser in das entsprechende Datenmodell übertragen. Wird durch den Benutzer der Pfad geändert, also eine andere Aktion selektiert, so lädt der Presenter das Datenmodell der neuen Aktion. Zukünftige Shortcutänderungen werden dann in dieses Datenmodell übertragen.

\subsubsection{ShortcutStructurePresenter}

Da bei den beiden Komponenten TreeTable und BreadCrumb die selben Daten präsentiert werden, kommt zur Abgleichung ebenfalls das MVP-Architekturmuster zum Einsatz, wobei die beiden genannten Komponenten die Views darstellen. Der Presenter (siehe Anhang \ref{ShortcutStructurePresenter}) erhält über den Konstruktor ein \textbf{ShortcutStructureModel} und eine beliebige Anzahl von \textbf{IShortcutStructureViews}. 

In \autoref{fig:ishortcutstructureview} wird ersichtlich, dass eine View einen \textbf{IEditorShortcutNode} und einen \textbf{AditoTreePath} besitzt. Der \textbf{IEditorShortcutNode} hält die in Abschnitt \ref{DatenmodellFunc} beschriebene Baumstruktur der Aktionen und der Pfad gibt an, welcher Knoten des Baums gerade selektiert ist. Über Änderung dieser Attribute informieren Listener, welche der View über die entsprechenden Methoden hinzugefügt werden können (z.B. \textbf{addPathChangeListener(...)}). Da das \textbf{ShortcutStructureModel} die gleiche Funktionalität benötigt, wie die View, implementiert es auch das Interface \textbf{IShortcutStructureView} (siehe Anhang \ref{ShortcutStructureModel}).

Im Konstruktor des \textbf{ShortcutStructurePresenters} (siehe Anhang \ref{ShortcutStructurePresenter}) werden sowohl dem Model als auch den einzelnen Views Pfad- und Node-Listener hinzugefügt. Löst ein Listener des Models aus, so werden die Änderungen in alle Views übertragen. Löst ein Listener einer View aus, so werden die Änderungen in das Model übertragen. Da dadurch wiederum der Listener des Models anschlägt, werden auch die anderen Views aktualisiert. So wird gewährleistet, dass alle Views und das Model zu jedem Zeitpunkt die gleichen Informationen besitzen.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\linewidth]{../graphic/diagrams/CD_ShortcutStructurePresenter/ShortcutStructurePresenter}
	\caption{ShortcutStructurePresenter}
	\label{fig:shortcutstructurepresenter}
\end{figure}

\newpage